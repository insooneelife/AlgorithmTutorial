// 상호 배타적 집합

// 어떤 학교에 N명의 사람이 있다고 가정해보자.
// 학교에서 이 사람들은 처음에는 흩어져 있다가,
// 서로 같은 학과임을 확인하면 같이 그룹을 만든다.
// 만약 두 그룹이 서로가 같은 학과임을 확인하면 두 그룹을 합한 더 큰 그룹을 만든다.
// 이러한 상황을 알고리즘으로 표현하려면 어떻게 해야 할까?

// 이 상황을 표현하기 위해 다음과 같은 연산들이 필요하다.
// Find : 어떤 원소가 속한 그룹을 알아내는 연산
// Union : 두 그룹을 합치는 연산


// 가장 먼저 배열로 구현한다고 가정해보자.
// group[i]라는 배열을 만들고 i번 원소가 속한 그룹의 id를 저장한다.
// 이렇게 하면, i번 원소가 어느 그룹에 속한지 알아내는것은 (Find 연산) O(1) 시간에 가능하다.
// 하지만 두 그룹을 합치기 위해서는(Union 연산) O(N)의 시간이 필요하다. 
// 그러므로 배열로 구현하는것은 부적절하다.

// 다음으로 트리를 이용한다고 가정해보자.
// 각각의 집합을 하나의 루트를 갖는 트리로 대응시켜보자.
// 모든 원소들이 자신의 부모노드를 참조할 수 있다면 (자신이 루트라면 자기자신을 참조),
// 모든 원소들은 자신의 루트를 알아낼 수 있고,
// 이 루트를 각 그룹의 id로 사용할 수 있을 것이다.
// Find 연산은 어떤 원소의 루트를 찾는 방법으로 구현하면 된다.
// Union 연산은 어떤 두 다른 집합에 있는 원소들의 루트를 찾고, 한쪽 루트가 다른쪽 루트를 부모로 참조하면 될 것이다.
 

